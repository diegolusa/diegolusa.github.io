
O JavaScript é uma das linguagens de programação mais amplamente utilizadas no mundo, especialmente no desenvolvimento de aplicações web. Criada em 1995 por Brendan Eich, ela foi inicialmente projetada para adicionar interatividade a páginas web. Hoje, o JavaScript evoluiu para uma linguagem extremamente versátil, usada tanto no *front-end *quanto no *back-end*, sendo um dos pilares fundamentais da web moderna. É uma linguagem interpretada, o que significa que pode ser executada diretamente pelos navegadores ou por motores como o V8, sem a necessidade de compilação prévia.

Atualmente o JavaScript desempenha um papel central na construção de interfaces de usuário interativas, permitindo que desenvolvedores criem experiências dinâmicas e responsivas. Ele funciona em conjunto com HTML e CSS para formar a base do desenvolvimento web. Com a introdução de bibliotecas e frameworks como React, Angular e Vue.js, o JavaScript se tornou ainda mais poderoso no *front-end*, possibilitando a criação de aplicações complexas e escaláveis. No *back-end*, com a chegada do [Node.js](https://nodejs.org/en), o JavaScript ampliou seu alcance, permitindo a construção de APIs e servidores eficientes. Além disso, é utilizado em outras áreas, como desenvolvimento de aplicativos móveis através de frameworks como React Native, criação de jogos e até automação de tarefas.

A popularidade do JavaScript é impulsionada pela sua comunidade, que fornece uma vasta coleção de bibliotecas e ferramentas, além de suporte contínuo. Seu uso é quase onipresente na indústria de tecnologia, e aprender JavaScript é essencial para qualquer pessoa interessada em desenvolvimento de software moderno. Ele oferece uma curva de aprendizado que equilibra simplicidade para iniciantes e profundidade para profissionais avançados, consolidando-se como uma habilidade indispensável no cenário tecnológico atual.

Em nosso estudo, apresentaremos os conceitos básicos da linguagem e gradativamente vamos adicionando novos recursos e potencialidades da linguagem JavaScript e ferramentas associadas.

## Sintaxe

A sintaxe do JavaScript é projetada para ser simples e flexível, permitindo que desenvolvedores iniciantes e experientes escrevam código de maneira eficiente. Ela é inspirada em linguagens como **Java** e **C**, mas com características próprias que a tornam única no desenvolvimento de aplicações web. JavaScript é uma linguagem case-sensitive, ou seja, distingue maiúsculas de minúsculas, e seu código é organizado em declarações que terminam, opcionalmente, com ponto e vírgula (;).

JavaScript é dinamicamente tipada, o que significa que não é necessário declarar explicitamente o tipo das variáveis; elas podem mudar de tipo em tempo de execução. As variáveis são declaradas com as palavras-chave `var`, `let` ou `const`, como veremos na sequência. A linguagem suporta operadores aritméticos, lógicos e de comparação, permitindo a criação de condições e estruturas de controle como `if`, `for` e `while`. Além disso, o JavaScript é orientado a objetos, mas utiliza um modelo baseado em protótipos, o que o diferencia de linguagens com orientação a objetos clássica.

Outro aspecto fundamental é a sua capacidade de manipular o **DOM (Document Object Model)**, permitindo alterar dinamicamente o conteúdo e o estilo das páginas web. JavaScript também suporta funções anônimas e de alta ordem, tornando-se poderoso para a programação funcional. A linguagem oferece suporte a programação assíncrona, permitindo lidar com operações que ocorrem ao longo do tempo, como requisições HTTP ou interações com APIs, através de promises e async/await.

```javascript

let nome = "Maria";

function cumprimentar(nome) {
    return `Olá, ${nome}! Seja bem-vinda.`;
}


document.body.innerHTML = cumprimentar(nome);
```

Nesse exemplo, o script utiliza uma função simples para gerar uma mensagem de boas-vindas e a exibe no corpo da página. Esse código demonstra a clareza da sintaxe do JavaScript e sua capacidade de interagir com o HTML, destacando sua importância no desenvolvimento web. Observe que a delimitação do corpo da função se dá pelo uso de `{}`, definindo o início e o término do bloco.

## Variáveis


Para declarar variáveis, temos a disposição três formas distintas: `var`, `let`, e `const`.

- **`var`**:  As variáveis declaradas com `var` têm escopo de função ou escopo global. Se declaradas em uma função, ficam disponíveis no corpo da função, em qualquer parte dele. Já se declarada fora de uma função tornam-se globais, o que significa dizer que podem ser acessadas em qualquer parte do script.  Outra característica chama-se *hoisting* (elevação), que nada mais é do que trazer automaticamente a declaração da variável para o início do escopo ao qual pertence.

- **`let`**: As variáveis declaradas com `let` têm escopo de bloco, o que significa que são acessíveis apenas dentro do bloco em que foram declaradas. Não podem ser redeclaradas e não tem opção de *hoisting*.

- **`const`**: Variáveis declaradas com `const` também têm escopo de bloco e são imutáveis após a inicialização. Uma vez informado uma referência para a variável, não poderá mais modificar.



```javascript

var x = 10;
console.log(x);


let y = 20;
console.log(y); 


const z = 30;
console.log(z); 
```

### Escopos

O escopo define onde as variáveis estão acessíveis. Existem dois tipos principais de escopos: **escopo global** e **escopo local**.

- **Escopo Global**: As variáveis globais são acessíveis em qualquer lugar do script.

- **Escopo Local**: As variáveis locais são acessíveis apenas dentro da função ou bloco em que foram declaradas. Fora deste espaço elas não existem,


```javascript

var valor_global = 100;

function funcaoExemplo() {
  var valor_local = 200;
  console.log(valor_global); 
  console.log(valor_local); 
}

console.log(valor_local)
```

Perceba no exemplo que `valor_global` está sendo acessado no corpo da função `funcaoExemplo`. Isso é possível pois trata-se de uma variável global. Internamente a função declara outra variável chamada `valor_local`, que está sendo lida no último comando. Neste caso, o resultado será um erro, pois `valor_local` é uma variável local e, portanto, não existe fora do escopo a qual pertence.


## Operadores


Operadores sãos símbolos utilizados na linguagem JavaScript para representar operações aritméticas, de comparação, atribuição , concatenação e lógicas. Com algumas exceções, são os mesmos encontrados nas ns *Java* e *C* [@dhis2jsintro].

!!! info "Quais são os operadores?"

    === "Aritméticos"

        - **Adição (+)**: Soma dois valores.
        - **Subtração (-)**: Subtrai o segundo valor do primeiro.
        - **Multiplicação (*)**: Multiplica dois valores.
        - **Divisão (/)**: Divide o primeiro valor pelo segundo.
        - **Resto da Divisão (%)**: Retorna o resto da divisão inteira do primeiro valor pelo segundo.
        - **Incremento (++)**: Incrementa o valor de uma variável em 1.
        - **Decremento (--)**: Decrementa o valor de uma variável em 1.
      
    === "Atribuição"

        - **Atribuição Simples (=)**: Atribui um valor à variável.
        - **Atribuição com Adição (+=)**: Adiciona o valor à variável e atribui o resultado.
        - **Atribuição com Subtração (-=)**: Subtrai o valor da variável e atribui o resultado.
        - **Atribuição com Multiplicação (*=)**: Multiplica o valor da variável e atribui o resultado.
        - **Atribuição com Divisão (/=)**: Divide o valor da variável e atribui o resultado.
        - **Atribuição com Resto da Divisão (%=)**: Calcula o resto da divisão e atribui o resultado.
      
    === "Comparação"

        - **Igual (==)**: Verifica se dois valores são iguais.
        - **Estritamente Igual (===)**: Verifica se dois valores são iguais em valor e tipo.
        - **Diferente (!=)**: Verifica se dois valores não são iguais.
        - **Estritamente Diferente (!==)**: Verifica se dois valores não são iguais em valor ou tipo.
        - **Maior que (>)**: Verifica se o primeiro valor é maior que o segundo.
        - **Maior ou Igual (>=)**: Verifica se o primeiro valor é maior ou igual ao segundo.
        - **Menor que (<)**: Verifica se o primeiro valor é menor que o segundo.
        - **Menor ou Igual (<=)**: Verifica se o primeiro valor é menor ou igual ao segundo.
      
    === "Lógico"

        - **AND lógico (&&)**: Retorna verdadeiro se ambas as expressões forem verdadeiras.
        - **OR lógico (||)**: Retorna verdadeiro se pelo menos uma das expressões for verdadeira.
        - **NOT lógico (!)**: Inverte o valor da expressão, se era verdadeira torna-se falsa e vice-versa.
    
    === "Concatenação"

        - **Concatenação (+)**: Concatena duas strings.



## Controle de Fluxo


Assim como outras linguagens, em JavaScript, os comandos de desvio de fluxo permitem controlar a execução do código, permitindo a tomada de decisões com base em condições específicas ou executando iterações sobre coleções de dados. Vamos começar analisando o comando `if`.

### Comando `if`

O comando `if...else` permite executar um bloco de código se o resultado da expressão lógica (condição) for **verdadeira** e outro bloco de código se o resultado for **falso**.

A sintaxe do comando compreende a palavra reservada `if`, a condição lógica entre `()`, acompanhado do bloco verdade delimitado por `{}`. Ter um bloco para executar quando a condição é falsa é opcional, mas quando informado, deve ser após a palavra reservada `else`.

```javascript
let idade =10; // Solicita a idade do usuário

if (idade >= 18) {
    alert("Você é maior de idade.");
} else {
    alert("Você é menor de idade.");
}

```


### Comando `switch...case`

O comando `switch...case` permite avaliar o conteúdo de uma variável e executar blocos específicos de código com base em valores discretos. É particulamente útil para avaliar um pequeno conjunto de opções cuja ação resultante de cada valor é distinta. Cada caso é inicia com a palavra reservada `case`, acompanhada do valor e dois pontos. Na sequência, seguem as instruções que devem ser executadas na ocorrência de tal valor, até encontrar o comando `break`, cuja função é encerrar o comando `switch`.

```javascript

let valor=parseInt(prompt("Informe um valor inteiro"))

switch (valor) {
  case 1:
    // Bloco de código a ser executado se a variável valor for igual a 1
    break;
  case 2:
    // Bloco de código a ser executado se a variável valor for igual a 2
    break;
  default:
    // Não sendo nenhum dos anteriores, executa este caso padrão
}
```

### Operador ternário

O operador ternário é uma forma simplificada de realizar testes condicionais que retornam um valor quando verdadeiro e outro, quando falso.

No exemplo a seguir, a variável `resultado` vai receber `Aprovado` ou `Tente novamente`, a depender do resultado de `nota > 6`.

```javascript
const resultado = nota> 6 ? "Aprovado" : "Tente novamente";

```

### Laço `for`

O comando `for` é usado para iterar sobre uma lista de itens por um número específico de vezes (conhecido a priori). Na estrutura do comando, temos `inicialização`, que especifica os valores iniciais das variáveis de controle, `condição`, onde colocamos um teste condicional para determinar a condição de parada do laço e, finalmente, `incremento`, para determinar a alteração das variáveis de controle ao fim de cada iteração. Cada segmento deve ser separado por ponto-e-vírgula, resultando em um comando com o padrão `for (inicialização; condição; incremento)`.


Observe como faríamos para apresentar os números de 1 a 10 usando o laço *for*

```javascript
for (let i = 1; i <= 10; i++) {
    console.log("Número:", i);
}
```


### Laço `while`

O comando `while` executa um bloco de código enquanto uma condição especificada for verdadeira. Normalmente utilizando ele quando desconhecemos quantas iterações serão necessárias para alcançar a condição de parada.

```javascript
while (condição) {
  // Bloco de código a ser repetido enquanto a condição for verdadeira
}
```

### Laço `do...while`

O comando `do...while` é semelhante em sintaxe e objetivo ao `while`. O que o torna diferente é o fato de que **sempre** irá executar o bloco de comando, no mínimo, uma vez.

```javascript
do {
  // Bloco de código a ser executado pelo menos uma vez
} while (condição);
```

### Comandos `break` e `continue`

Sabemos que os laços de repetição iteram enquanto as condições de parada não foram satisfeitas. Por vezes, a condição de parada não é o único critério para determinar se um laço deve finalizar. Neste caso, podemos encerrar prematuramente um laço de repetição utilizando o comando `break`. Em outras situações é preciso ignorar um conjunto de instruções que seguem a partir de determinado ponto e, para esta finalidade temos a disposição o comando `continue`.

```javascript
for (var i = 0; i < 10; i++) {
  if (i === 5) {
    break; // Interrompe o loop quando i é igual a 5
  }
  if (i === 3) {
    continue; // Pula para a próxima iteração quando i é igual a 3
  }
  console.log(i);
}
```


## Tratamento de Exceções


O tratamento de exceções é feito usando blocos `try...catch`. O bloco `try` corresponde ao conjunto de instruções do fluxo normal do código que podem lançar exceções. Os blocos `catch`, por sua vez, permitem adicionar instruções a ser executadas caso alguma exceção seja lançada. Opcionalmente podemos colocar o bloco `finally` na estrutura, o qual executará em todos os cenários (com ou sem lançamento da exceção).

```javascript
try {
   var x = y / 0;
} catch (erro) {
  console.log("Ocorreu um erro: " + erro.message);
} finally {
  console.log("Este bloco sempre será executado.");
}
```

!!! note "O que são exceções?"
    Em programação, uma exceção é um evento ou condição que ocorre durante a execução de um programa e interrompe seu fluxo normal. Geralmente, as exceções representam erros ou situações inesperadas que o programa não consegue processar automaticamente, como tentativa de acessar um arquivo inexistente, divisão por zero, entrada inválida do usuário, ou problemas de conexão com a internet. Embora as exceções frequentemente estejam associadas a erros, elas são usadas para sinalizar condições especiais que exigem tratamento específico pelo desenvolvedor, como alguma condição inválida do contexto do problema. Todas as exceções genéricas são disponibilizadas na biblioteca base da própria linguagem. No caso do JavaScript, você encontra a lista procurando pelos objetos globais de [erro](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error).


## Promises



As Promises são uma funcionalidade introduzida no ECMAScript 6 (ES6) para lidar com operações assíncronas de forma mais clara e organizada. Elas representam um valor que pode estar disponível agora, no futuro ou nunca, permitindo a execução de código que depende de resultados de operações como requisições de rede, leitura de arquivos ou temporizadores. Antes do advento das Promises, o uso de callbacks era a principal forma de tratar operações assíncronas, mas isso frequentemente resultava no que é chamado de “callback hell” — código aninhado e difícil de manter.

Uma Promise pode estar em um dos três estados: pendente (*pending*), resolvida (*fulfilled*) ou rejeitada (*rejected*). Quando uma operação assíncrona começa, a Promise está no estado pendente. Caso a operação seja concluída com sucesso, a Promise passa para o estado resolvido, disparando a execução do método then. Por outro lado, se a operação falhar, a Promise entra no estado rejeitado, e o método catch é chamado para tratar o erro. Isso cria uma cadeia de eventos que melhora a legibilidade e a organização do código.

Promises são criadas usando o construtor *Promise*, que recebe uma função de callback com dois parâmetros: resolve e reject. O resolve é chamado para indicar sucesso, enquanto o reject é chamado para indicar uma falha. Métodos como *Promise.all* e *Promise.race* permitem lidar com múltiplas Promises de maneira simultânea, seja esperando todas serem resolvidas ou tratando o resultado da primeira que completar.

Um exemplo prático seria uma função que faz uma requisição a uma API. Com Promises, é possível definir o que deve acontecer quando os dados forem recebidos ou caso ocorra um erro. Isso elimina a necessidade de aninhar múltiplos callbacks, tornando o código mais limpo e fácil de entender.

As Promises também servem de base para a implementação do `async/await`, introduzido no ECMAScript 2017, que simplifica ainda mais o tratamento de operações assíncronas, permitindo escrever código assíncrono que parece síncrono. Assim, Promises revolucionaram a forma como o JavaScript lida com assincronicidade, melhorando significativamente a legibilidade, a manutenção e o controle de erros em aplicações modernas.

### Estados e callbacks

Uma promise é um objeto que representa a eventual conclusão (ou falha) de uma operação assíncrona e seu valor resultante. Uma promise pode estar em um dos três estados:

- **Pending (Pendente)**: Estado inicial, que não foi realizada nem rejeitada.
- **Fulfilled (Realizada)**: A operação foi concluída com sucesso.
- **Rejected (Rejeitada)**: A operação falhou.


Para criar uma promise, utilizamos o construtor `Promise` que aceita uma função de dois parâmetros: `resolve` e `reject`.

```javascript
const minhaPromise = new Promise((resolve, reject) => {
  
  //executando alguma operação que leva tempo para concluir
  let sucesso = true;

  if (sucesso) {
    resolve("Operação realizada com sucesso!");
  } else {
    reject("Operação falhou.");
  }
});
```

Para tratar do resultado de uma promise, usamos os métodos `then`, `catch` e `finally`.

O método `then` é utilizado para tratar o sucesso da promise, ou seja, a função assíncrona executou com sucesso e precisamos realizar alguma ação como efeito de tal resultado.

```javascript
minhaPromise.then((valor) => {
  console.log(valor); // "Operação realizada com sucesso!"
});
```


O método `catch` é usado para lidar com a falha da promise, ou seja, executar alguma ação em função da falha na execução.

```javascript
minhaPromise.catch((erro) => {
  console.log(erro); // "Operação falhou."
});
```

O método `finally`, por sua vez, é chamado quando a promise é concluída, independente do resultado. É um método que sempre será executado.

```javascript
minhaPromise.finally(() => {
  console.log("Operação concluída."); // Será executado sempre
});
```



### Função `fetch`

A função `fetch` é nativa do JavaScript. Ela permite fazer requisições HTTP assíncronas para acessar e manipular recursos pela rede. Por ser assíncrona, retorna uma `Promise` que resolve com a resposta da requisição, facilitando o consumo de recursos remotos [@dofetch2024].

Sua assinatura (`fetch(url, [options])`) compreende um parâmetro obrigatório chamado `url`, o qual deve receber o endereço do recurso. O outro parâmetro, de nome `options`, é opcional e deve ser informado como um objeto contendo um ou mais dos atributos a seguir.

- **method**: O método HTTP a ser usado (e.g., `GET`, `POST`, `PUT`, `DELETE`). O padrão é `GET`.
- **headers**: Um objeto contendo cabeçalhos HTTP a serem enviados com a requisição.
- **body**: O corpo da requisição. Pode ser uma string, um objeto, um `FormData`, etc.
- **mode**: O modo da requisição (e.g., `cors`, `no-cors`, `same-origin`).
- **credentials**: Indica se os cookies devem ser enviados com a requisição (`omit`, `same-origin`, `include`).
- **cache**: O modo de cache (e.g., `default`, `no-store`, `reload`, `no-cache`, `force-cache`, `only-if-cached`).
- **redirect**: O modo de redirecionamento (`follow`, `error`, `manual`).
- **referrer**: Referrer da requisição (`client`, URL, ou vazio).
 

!!! info  "Exemplos de Uso"

    === "Requisição Simples (GET)"

        ```javascript
        fetch('https://api.exemplo.com/dados')
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error('Erro:', error));
        ```


    === "Requisição com Parâmetros (POST)"

        ```javascript
        fetch('https://api.exemplo.com/dados', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            chave: 'valor'
        })
        })
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error('Erro:', error));
        ```

    === "Tratamento da Resposta"

        O objeto `Response` retornado pela função `fetch` possui diversos métodos para processar os dados da resposta:

        - **text()**: Retorna uma `Promise` que resolve com o corpo da resposta como uma string.
        - **json()**: Retorna uma `Promise` que resolve com o corpo da resposta como um objeto JSON.
        - **blob()**: Retorna uma `Promise` que resolve com o corpo da resposta como um Blob.
        - **formData()**: Retorna uma `Promise` que resolve com o corpo da resposta como um FormData.
        - **arrayBuffer()**: Retorna uma `Promise` que resolve com o corpo da resposta como um ArrayBuffer.

        ```javascript
        fetch('https://api.exemplo.com/dados')
        .then(response => {
            if (!response.ok) {
            throw new Error('Erro na rede: ' + response.statusText);
            }
            return response.json();
        })
        .then(data => console.log(data))
        .catch(error => console.error('Erro:', error));
        ```
        Podemos utilizar o serviço [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com) para consumir uma API e testar nossos códigos que utilizam a função `fetch`.


## Documento Object Model (DOM)


O Document Object Model (DOM) é uma interface de programação que representa a estrutura de documentos HTML e XML como uma árvore hierárquica. Ele permite que linguagens de programação, como JavaScript, acessem e manipulem dinamicamente o conteúdo, a estrutura e o estilo de uma página web enquanto ela está sendo exibida no navegador. No DOM, cada parte do documento, como elementos, atributos e textos, é representada como um nó, que pode ser modificado, adicionado ou removido.

O DOM transforma um documento estático em um ambiente interativo, possibilitando criar experiências dinâmicas para os usuários. Por exemplo, ao clicar em um botão, é possível adicionar novos elementos à página, alterar estilos ou até atualizar dados sem recarregar o documento. Essa capacidade é essencial para o funcionamento de aplicações web modernas.

O DOM é independente de linguagem, mas é amplamente utilizado com JavaScript devido à sua integração nativa nos navegadores. Ele organiza os elementos do HTML em uma estrutura hierárquica, onde o nó raiz é o objeto document, que contém outros nós representando elementos como <html>, <body>, e seus filhos. Por meio de métodos e propriedades fornecidos pelo DOM, é possível navegar nessa árvore e interagir com os elementos.

Essa interface é uma parte fundamental do desenvolvimento web, pois permite a criação de aplicações dinâmicas e interativas, onde o conteúdo e a aparência de uma página podem ser alterados em tempo real, sem necessidade de recarregar o navegador. O DOM, portanto, é a ponte que conecta a estrutura do HTML com o poder da programação, transformando páginas web simples em experiências ricas e responsivas.


### Objeto `window`

O objeto global `window` representa uma janela ou aba aberta no navegador. Ele é a raiz da hierarquia de objetos do navegador e fornece acesso a uma ampla variedade de funcionalidades, incluindo a manipulação da janela, controle de eventos, navegação e interação com o *Document Object Model (DOM)*. Todas as variáveis globais, funções e objetos declarados em um script são automaticamente associados ao objeto `window`.

Em sua estrutura, o objeto contém diversas propriedades e métodos importantes. Por exemplo, a propriedade `document` dá acesso ao DOM do documento, permitindo manipular elementos e estilos da página. Outra propriedade chama-se `location`, que fornece informações sobre a URL atual e permite redirecionar o navegador. A propriedade `history`, por sua vez, permite manipular o histórico de navegação. 

Além de propriedades, existem métodos para exibir caixas de diálogo, como `alert()`, `confirm()` e `prompt()`, além de funções para executar ações após um intervalo ou repetidamente, como `setTimeout()` e `setInterval()`. Propriedades como `innerWidth` e `innerHeight` permitem acessar as dimensões da janela, enquanto eventos como `onload`, `onresize` e `onscroll` permitem reagir a interações do usuário ou mudanças na janela.

Além disso, o `window` também encapsula APIs avançadas, como `localStorage` e `sessionStorage`, usadas para armazenamento local, `fetch` para fazer requisições HTTP, e console para depuração. No contexto do navegador, ele também inclui subobjetos como `navigator`, que fornece informações sobre o ambiente do usuário, e `screen`, que detalha as dimensões e configurações da tela.

Por ser objeto global, não é necessário referenciar explicitamente `window` para acessar seus métodos ou propriedades. Por exemplo, chamar `alert('Oi')` é equivalente a `window.alert('Oi')`. 

=== "Propriedades"

    - `window.document` : Retorna o documento HTML carregado na janela.
    - `window.location`:  Retorna um objeto contendo informações sobre a URL da página.
    - `window.navigator`: Retorna um objeto contendo informações sobre o navegador.
    - `window.innerWidth` e `window.innerHeight`: Retornam a largura e a altura internas (em pixels) da janela do navegador, incluindo barras de rolagem, mas excluindo a moldura do navegador.
    - `window.outerWidth` e `window.outerHeight`: Retornam a largura e a altura externas (em pixels) da janela do navegador, incluindo barras de rolagem e a moldura do navegador.
    - `window.screen`: Retorna um objeto contendo informações sobre a tela do dispositivo.
    - `window.history`: Retorna o objeto de histórico do navegador, permitindo navegação entre as páginas visitadas.
    - `window.localStorage` e `window.sessionStorage`: Oferecem acesso aos mecanismos de armazenamento local e de sessão do navegador, respectivamente, permitindo armazenar dados localmente no navegador do usuário.
    - `window.frames`: Retorna uma coleção de objetos representando todas as frames contidas na janela.
    - `window.parent`: Retorna a janela pai da janela atual, útil quando uma janela abre outra.



=== "Métodos"

    - `window.alert(message)`: Exibe um diálogo de alerta com o texto especificado.
    - `window.confirm(message)`: Exibe um diálogo de confirmação com o texto especificado, retornando `true` se o usuário clicar em "OK" e `false` se clicar em "Cancelar".
    - `window.prompt(message, default)`: Exibe um diálogo solicitando que o usuário insira um texto, com uma mensagem opcional e um valor padrão opcional.
    - `window.open(url, name, features)`: Abre uma nova janela do navegador com o URL especificado.
    - `window.close()`": Fecha a janela do navegador atual.
    - `window.setTimeout(function, milliseconds)`: Executa uma função depois de um certo número de milissegundos.
    - `window.setInterval(function, milliseconds)`: Executa uma função repetidamente, com um intervalo de tempo especificado entre cada execução.
    - `window.clearTimeout(timeoutID)` e `window.clearInterval(intervalID)`: Cancelam a execução de uma função agendada com `setTimeout()` ou `setInterval()`.


=== "Eventos"

    Alguns dos eventos mais comuns associados ao objeto `window` incluem:

    - `load`: É acionado quando o documento e todos os recursos associados foram completamente carregados.
    - `resize`: É acionado quando a janela do navegador é redimensionada.
    - `scroll`: É acionado quando o usuário rola a página.
    - `beforeunload` e `unload`: São acionados quando o documento está prestes a ser descarregado ou completamente descarregado, respectivamente.




### Propriedade `document`

A propriedade `document` está disponível no contexto de execução do JavaScript no navegador. Trata-se de um propriedade do objeto global `window`, cuja função é representar o DOM da página. Embora trata-se de uma propriedade, trata-se de um objeto, com diversas propriedades e métodos a disposição do desenvolvedor. Vejamos alguns exemplos na sequência.

=== "Propriedades"

    Propriedades são atributos do objeto (como se fossem variáveis), através das quais podemos ler ou escrever valores. Algumas propriedades importantes do objeto `document` são:

    - `document.URL`: retorna a URL do documento.
    - `document.title`: permite obter ou definir o título do documento.
    - `document.body`: retorna a referência ao elemento `<body>` do documento.
    - `document.head`: retorna a referência ao elemento `<head>` do documento.
    - `document.documentElement`: retorna o elemento `<html>` do documento.
    - `document.domain`: Retorna o domínio do servidor que serve o documento.
    - `document.referrer`: retorna a URL do documento que levou o usuário a este documento.
    - `document.forms`: retorna uma coleção de todos os elementos `<form>` no documento.
    - `document.images`: retorna uma coleção de todos os elementos `<img>` no documento.
    - `document.links`: retorna uma coleção de todos os elementos `<a>` que têm um atributo `href` no documento.
    - `document.scripts`: retorna uma coleção de todos os elementos `<script>` no documento.

    Outras propriedades podem ser consultadas no site [Developers Mozilla](https://developer.mozilla.org/en-US/docs/Web/API/Document).

=== "Métodos"

    Métodos são funções que permitem solicitar ao objeto determinadas ações. Tal qual ocorrem com as propriedades, muitos métodos estão disponíveis, mas ficaremos restritos aos mais relevantes neste momento.


    !!! note "Principais Métodos"

        === "`document.getElementById(id)`"

            Retorna uma referência ao elemento que possui o atributo `id` com o valor especificado.

            ```javascript
            var elemento = document.getElementById("logotipo");
            ```

        === "`document.getElementsByClassName(className)`"

            Retorna uma coleção de elementos que têm, no atributo `class`, o nome da classe informada como parâmetro. Observe o exemplo.

            ```javascript
            var elementos = document.getElementsByClassName("cm-line")

            for (const e of elementos){
                console.log(e)
            }

            ```

        === "`document.getElementsByName(name)`"

            Retorna uma coleção de elementos cujo atributo `name` contém o valor informado como parâmetro.

            ```javascript
            var elementos = document.getElementsByName("viewport")
            ```

        === "`document.getElementsByTagName(tagName)`"

            Retorna uma coleção de todos os elementos da tag indicada por parâmetro.

            ```javascript
            var elementos = document.getElementsByTagName("div")
            ```

        === "`document.querySelector(selector)`"

            É uma função que permite selecionar um elemento HTML em uma página usando um seletor CSS válido. O primeiro elemento encontrado, que condiz com o seletor, será retornado pelo método.  

            O método `querySelector()` aceita um parâmetro, que é uma string que representa o seletor CSS. Este seletor pode ser um ID, uma classe, um tipo de elemento, um seletor de atributo ou uma combinação deles. 

            No exemplo abaixo, estamos buscando a primeira ocorrência de elemento da classe `importante` no documento.


            ```javascript
            var elemento = document.querySelector(".importante");
            ```

            Se houver interesse em retornar todos os elementos que atendem ao seletor, devemos utilizar o método `document.querySelectorAll()`, iterando sobre o retorno.

        
        === "`document.createElement(tagName)`"

            Cria um novo elemento HTML especificado pelo nome da tag informado como parâmetro.

            ```javascript
                let parag = document.createElement("p")
                parag.textContent = texto
                document.body.appendChild(parag)

            ```   

        === "`document.write(text)`"
            Escreve conteúdo HTML diretamente no documento.

            ```javascript
                document.write("<h2>Teste</h2>")
            ```


        === "`document.addEventListener(event, function)`" 
        
            Adiciona um ouvinte (*listener*) de evento a um elemento do documento. Isso permite executar ações em resposta a eventos disparados.

            ```javascript
                let botao = document.getElementById("btn_calcular")
                botao.addEventListener("click",() => {document.alert("Ouvi seu evento de click")})
            ```

        === "`document.removeEventListener(event, function)`"

            Remove um ouvinte (*listener*) de evento de um elemento do documento previamente configurado.
        

=== "Eventos"

    Eventos são o resultado de ações de ações do usuário sobre os elementos da página ou mesmo estados do próprio sistema e navegador, por exemplo. Os eventos são emitidos e podem ser processados por funções específicas, escritas pelo desenvolvedor, para dar um efeito à ocorrência do evento (se você clica em um botão espera que alguma ação seja executada).

    Os eventos mais comuns associados ao objeto `document` incluem:

    - `DOMContentLoaded`: É acionado quando o HTML do documento foi completamente carregado e analisado, sem aguardar por folhas de estilo, imagens e subframes para concluir o carregamento.
    - `load`: É acionado quando todo o conteúdo do documento, incluindo imagens e folhas de estilo, foi completamente carregado.
    - `click`: É acionado quando um elemento é clicado pelo usuário.
    - `keydown`, `keyup`, `keypress`: São acionados quando uma tecla é pressionada e liberada.


### Propriedade `navigator`

A propriedade `navigator` está disponível no objeto `window`. Sua função é fornecer informações detalhadas sobre o navegador e o ambiente em que o código JavaScript está sendo executado. Na sequência estão algumas propriedades, métodos e eventos importantes disponíveis através da propriedade `navigator`.


=== "Propriedades"

    === "`navigator.userAgent`"
        Retorna a string do agente do usuário, que contém informações sobre o navegador, versão e sistema operacional.

    === "`navigator.appName`"
        Retorna o nome do navegador.

    === "`navigator.appVersion`"
        Retorna a versão completa do navegador.

    === "`navigator.platform`"
        Retorna a plataforma do sistema operacional em que o navegador está sendo executado.

    === "`navigator.language`"
        Retorna o idioma preferido do usuário, normalmente definido nas configurações do navegador.

    === "`navigator.cookieEnabled`"
        Retorna um booleano indicando se os cookies estão habilitados no navegador.

    === "`navigator.onLine`"
        Retorna um booleano indicando se o navegador está online ou offline.

    === "`navigator.plugins`"
        Retorna uma lista de plugins instalados no navegador.

=== "Métodos"

    === "`navigator.geolocation.getCurrentPosition()`"
        Retorna a localização atual do usuário.

    === "`navigator.getBattery()`"
        Retorna uma promessa que resolve com informações sobre o estado da bateria do dispositivo.

    === "`navigator.mediaDevices.getUserMedia()`"
        Permite acessar a câmera e o microfone do dispositivo.

    === "`navigator.vibrate()`"
        Ativa a vibração do dispositivo.


## Biblioteca jQuery

jQuery é uma biblioteca JavaScript muito popular por ser rápida, pequena e rica em recursos. Basicamente seu uso torna a varredura e manipulação de documentos HTML, manipulação de eventos, animação e Ajax muito mais simples do que utilizar código JavaScript *vanilla*.

!!! info "Nota"
    *Vanilla* é um termo utilizado para indicar o uso de uma tecnologia de forma pura, básica. Nenhuma biblioteca ou framework não nativo é aplicado.


Para incluir a última versão do jQuery em um projeto, podemos utilizar um CDN (*Content Delivery Network*) ou baixar a biblioteca e incluí-la localmente. Quando utilizamos CDN, adicionamos à tag  `<head>` do documento uma tag `<script>`, informando no atributo *src* da mesma o endereço de [CDN da versão desejada](https://releases.jquery.com/jquery/). Caso a opção seja baixar a biblioteca localmente, o atributo `src` deve receber o caminho local para o arquivo JavaScript. No exemplo está sendo utilizado o endereço de CDN.

```html
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
````


Ao adicionar o JQuery ao documento, temos a disposição um vasto conjunto de métodos utilitários para manipulação do DOM da página. No exemplo a seguir, o código está adicionando um *listener* de evento de click ao botão, de modo que, quando o botão receber o click, o texto de todos os parágrafos do documento irão ser atualizados com a informação *Você clicou no botão*.

```html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Exemplo jQuery</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        $(document).ready(function(){
            $("button").click(function(){
                $("p").text("Você clicou no botão!");
            });
        });
    </script>
</head>
<body>
    <p>Texto original</p>
    <button>Clique aqui</button>
</body>
</html>
```


Perceba que a sintaxe do JQuery sempre considera o uso da função `$()`, conhecida como *função JQuery*. O parâmetro da função deve ser um seletor válido, cuja sintaxe e funcionamento é idêntico aos seletores do CSS. Tal característica torna o uso da biblioteca mais familiar para profissionais que atuam na camada de *front-end*.

Conforme já comentamos, um dos benefícios do uso do JQuery é a manipulação do DOM em relação ao JavaScript *vanilla* devido à sua capacidade de simplificar significativamente a manipulação do DOM e garantir maior consistência entre navegadores. Antes do advento de padrões modernos, como o ECMAScript 6, e da padronização mais ampla das APIs do DOM nos navegadores, havia muitas inconsistências no suporte a métodos e propriedades, dificultando o desenvolvimento de aplicações web que funcionassem de forma uniforme em diferentes ambientes. O jQuery resolveu esse problema ao fornecer uma interface unificada e confiável para manipulação de elementos, garantindo que o mesmo código funcionasse da mesma maneira, independentemente do navegador ou da versão utilizada.

Além disso, o jQuery oferecia uma sintaxe muito mais curta e expressiva para realizar tarefas comuns, como selecionar elementos, adicionar eventos ou alterar propriedades de estilo. Com seus seletores baseados em CSS, ele tornava operações complexas no DOM mais acessíveis, eliminando a necessidade de código extenso e repetitivo. A manipulação de eventos também era simplificada, permitindo um gerenciamento mais eficiente de ações do usuário. Outra grande vantagem era o suporte integrado a animações e requisições AJAX, que eram difíceis de implementar de forma consistente utilizando apenas JavaScript *vanilla*. Vejamos alguns exemplos de uso:


!!! info "Ainda utiliza-se JQuery?"
    
    Muitos projetos legados utilizam a biblioteca em sua base de código. Já para novos desenvolvimentos, se forem projetos mais simples, faz sentido pensar em utilizar JQuery. Já para aplicações de maior porte e/ou complexidade, existem opções significativamente melhores, como os frameworks de front-end  React, Angular ou Vue.js, por exemplo.   





```javascript
// Adicionar um novo elemento como filho de outro
$("body").append("<p>Novo parágrafo</p>");
$("body").prepend("<p>Novo parágrafo no início</p>");

// Remover um elemento
$("#meuId").remove();

//lterar valor de atributos
$("img").attr("src", "nova-imagem.jpg");


//Adicionar *listener* de evento de clique
$("button").click(function(){
    alert("Botão clicado!");
});

//Adicionar *listener* de evento de "mouse sobre"
$("p").mouseover(function(){
    $(this).css("color", "red");
});

//Esconder ou mostrar elementos (`.hide()` e `.show()`)
$("#meuElemento").hide();
$("#meuElemento").show();
$("#meuElemento").toggle();

//Aplicação de estilos
$("p").css("color", "blue");

// Definição do conteúdo dos elementos
$("#meuElemento").html("<strong>Novo conteúdo HTML</strong>");
$("#meuElemento").text("Novo conteúdo de texto");
```

## Receitas

Nesta seção vamos apresentar alguns exemplos de código que buscam ilustrar funcionalidades importantes disponibilizadas via JavaScript pelo navegador. Iniciaremos falando sobre timers e intervalos.


### Timers e Intervalos

Por vezes precisamos que uma função execute ininterruptamente em intervalos de tempo predefinidos (a cada minuto, segundo, etc.). Podemos incorporar este comportamento através da função `setInterval`.

Caso você tenha a intenção de criar um relógio, você poderia utilizar o código a seguir como base.


```javascript
let timer = setInterval(() => {
        let currentDate = new Date();
        let hour = currentDate.getHours().toString().padStart(2,'0');
        let minutes = currentDate.getMinutes().toString().padStart(2,'0');
        let seconds = currentDate.getSeconds().toString().padStart(2,'0');
        document.body.innerHTML = `<h1>${hour}:${minutes}:${seconds}</h1>`;
      }, 1000);
```